---
layout: post
title: "两年前的一道面试题"
description: ""
category: ""
tags: [c++, template]
---
{% include JB/setup %}

这段时间一直在看sv6的代码，里面用到了很多c++11里面的新特性，各种右值引用、匿名函数、精确传递什么的，看得我头都大了。

不懂只好去查资料呗，于是就看到了type_traits的内容，不禁想到2012年初去百度面实习生的时候考官问我的一道题目。

题目是这样的：
    
    写一个模板类，要求这个模板类只能接受内置类型的参数（即为int、char之类的），如果传递了自定义类型作为模板参数，则要在编译的时候报错。

当时没有想出来，后来在回南京的火车上想出了这样的一种解法：

{% highlight cpp %}
template <typename T>
class Constraint;

template class Constraint<int> {};
template class Constraint<char> {};

template <typename T, typename C = Constraint<T> >
class FuckingTemplate {
    ......    
};

int main(int argc, char **argv) {
    FuckingTemplate<int> intT;      // compile OK
    FuckingTemplate<char> charT;    // compile OK
    FuckintTemplate<S> ST;          // compile error
    return 0;
}
{% endhighlight %}

FuckingTemplate带两个模板参数，第一个要求用户提供，第二个为默认模板参数并以第一个模板参数为参数。然后第二个模板参数Constraint只声明不定义，只特化了int和char两个版本。结果就是，如果传入了自定义类型S作为模板参数，则会因为找不到Constraint<S>的定义而发生编译错误。

这个做法看上去实在是不甚优雅，现在有了type_traits就可以这么做。

{% highlight cpp %}
#include <iostream>
#include <type_traits>

template <typename T>
class FuckingTemplate {
    static_assert(std::is_integral<T>::value, "parameter must be an integer\n");
    ......
};

int main(int argc, char **argv) {
    FuckingTemplate<int> intT;      // compile OK
    FuckingTemplate<char> charT;    // compile OK
    FuckintTemplate<S> ST;          // compile error
    return 0;
}
{% endhighlight %}

一行代码就可以搞定，可惜当年实在是太弱了，没有想到。这里面用到了c++11中的type_trait和static_assert，这些东西原先都是tr1中的内容，现在被吸收到了c++11标准中了，编译的时候指定-std=c++11就可以搞定。
