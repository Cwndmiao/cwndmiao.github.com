---
layout: post
title: "libdwarf and libunwind"
description: ""
category: "programming tools"
tags: [libdwarf, libunwind, debug]
---
{% include JB/setup %}
#关于DWARF

在开始的地方，首先要介绍下[DWARF](http://dwarfstd.org/)。

>DWARF is a debugging file format used by many compilers and debuggers to support source level debugging. It addresses the requirements of a number of procedural languages, such as C, C++, and Fortran, and is designed to be extensible to other languages. DWARF is architecture independent and applicable to any processor or operating system. It is widely used on Unix, Linux and other operating systems, as well as in stand-alone environments.

DWARF翻译过来是侏儒的意思，类似于Windows下的COFF格式（存在于pdb文件中？），也是一种调试信息的格式，只不是它是体系结构和操作系统中立的。用gcc编译源代码时加上-g选项，就会在elf文件（一般是末尾）加上若干名为.debug.xxx的段，这里面记录的就是该elf文件的调试信息。

    11:01:27 testvm:~/test # objdump -h ./with_dwarf   
    ./with_dwarf:     file format elf64-x86-64
    Sections:
    ......
    27 .debug_aranges 00000030  0000000000000000  0000000000000000  00000988  2**0
        CONTENTS, READONLY, DEBUGGING
    28 .debug_info   00000108  0000000000000000  0000000000000000  000009b8  2**0
        CONTENTS, READONLY, DEBUGGING
    29 .debug_abbrev 0000006d  0000000000000000  0000000000000000  00000ac0  2**0
        CONTENTS, READONLY, DEBUGGING
    30 .debug_line   0000004d  0000000000000000  0000000000000000  00000b2d  2**0
        CONTENTS, READONLY, DEBUGGING
    31 .debug_str    00000097  0000000000000000  0000000000000000  00000b7a  2**0
        CONTENTS, READONLY, DEBUGGING
    32 .debug_loc    00000060  0000000000000000  0000000000000000  00000c11  2**0
        CONTENTS, READONLY, DEBUGGING

安装dwarfdump后，即可以用该命令dump出某个elf文件中调试信息段的内容。至于每个section里面到底放了什么东西，可以参考DWARF的[文档](http://dwarfstd.org/doc/DWARF4.pdf)。

>DWARF2 contains .debug_frame information for helping debuggers figure out how to unwind frames (i.e. how to restore the stack to the previous frame from any instruction executing using the current frame.

在这些section当中，有一个尤为重要，即为.debug_frame。有了.debug_frame，我们可以在执行到使用当前call stack frame的任何一条指令时，推断出上一个call stack frame的内容。x86_64的ABI默认不保存恢复stack frame pointer，所以唯有借助.debug_frame段才可以进行栈回溯。关于.debug_frame的具体构造，可以参考[这里](http://ucla.jamesyxu.com/?p=231)。

#关于libunwind

以上DWARF只是定义了应该在目标文件中存储的调试信息的格式，至于利用这些调试信息来达到堆栈展开或者栈回溯的目的，则是[libunwind](http://www.nongnu.org/libunwind/)做的事情。当然libunwind能做的也不仅仅局限于这些，利用libunwind还可以实现non-local goto和efficient setjump，后面会给出相应的例子。然而，当用ldd查看gdb时，发现gdb并没有依赖于libunwind，于是推测gdb应该是自己实现了这堆功能。

>The primary goal of this project is to define a portable and efficient C programming interface (API) to determine the call-chain of a program. The API additionally provides the means to manipulate the preserved (callee-saved) state of each call-frame and to resume execution at any point in the call-chain (non-local goto). The API supports both local (same-process) and remote (across-process) operation. As such, the API is useful in a number of applications. 

##exception handing

##effcient setjump()

#C++中的exception handing

